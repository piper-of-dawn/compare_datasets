<!DOCTYPE html>
<html lang="en">
<meta name="viewport" content="width=device-width, initial-scale=1">

<head>
    <link href="https://api.fontshare.com/v2/css?f[]=switzer@2,1&f[]=supreme@2,1&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>
<div class="absolute inset-0 bg-grid bg-top"></div>



<div class="container">
    <div class="toc"> </div>
    <article class="card">

        <h1>Comparison Report</h1>

        <section id="Overview">
            <section id="Metadata">
                <h2>Metadata</h2>
                {{metadata}}
            </section>
            <section id="Result">Commentary</section>
            <table>
                <thead>
                    <tr>
                        <th>Column Name </th>
                        <th style="text-align: right;"> Jaccard Similarity</th>
                        <th>Result </th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>fund_symbol </td>
                        <td style="text-align: right;"> 1 </td>
                        <td>PASSED </td>
                    </tr>
                    <tr>
                        <td>price_date </td>
                        <td style="text-align: right;"> 0.980198</td>
                        <td>FAILED </td>
                    </tr>
                    <tr>
                        <td>nav_per_share </td>
                        <td style="text-align: right;"> 0 </td>
                        <td>FAILED </td>
                    </tr>
                    <tr>
                        <td>positive_change</td>
                        <td style="text-align: right;"> 1 </td>
                        <td>PASSED </td>
                    </tr>
                </tbody>
            </table>
            <section id="Jaccard Similarity">
                <h2>Jaccard Similarity</h2>



                <h5 class="PASSED">PASSED</h5>

                <p>

                </p>

                <p>The Jaccard similarity between the expected and tested dataframes is not 1 for all columns.
                    This means that the expected and tested dataframes have different values for the same column(s).</p>
            </section>
        </section>
        <section id="Value Comparisons">

            <section id="String Columns">
                <h2>String Columns</h2>

                <p class="sidenote">The string comparisons are done using the Levenshtein distance. The Levenshtein
                    distance
                    is the minimum number of single-character edits (insertions, deletions or substitutions) required to
                    change one word into the other.</p>

                <h5>True</h5>

                <p>
                <table>
                    <thead>
                        <tr>
                            <th>Column Name </th>
                            <th style="text-align: right;"> Total Levenshtein Distance</th>
                            <th>Result </th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>fund_symbol </td>
                            <td style="text-align: right;"> 0</td>
                            <td>PASSED </td>
                        </tr>
                    </tbody>
                </table>
                </p>

                <p>The Levenshtein distance between the expected and tested dataframes is 0 for all columns.This means
                    that
                    the expected and tested dataframes have the same values for the same column(s).</p>
            </section>

            <section id="Numeric Columns">
                <h2>Numeric Columns</h2>

                <p class="sidenote">The numeric comparisons are done using the Euclidean distance. The Euclidean
                    distance is
                    a measure of the straight line distance between two points in a space.
                    Given two points P and Q with coordinates (p1, p2, ..., pn) and (q1, q2, ..., qn) respectively, the
                    Euclidean distance d between P and Q is: d(P, Q) = sqrt((q1 - p1)² + (q2 - p2)² + ... + (qn - pn)²)
                    Columns are scaled to have a unit norm (magnitude or length of 1) for calculation of the Euclidean
                    Distance (Normalized). </p>

                <h5>False</h5>

                <p>
                <table>
                    <thead>
                        <tr>
                            <th>Column Name </th>
                            <th style="text-align: right;"> Euclidean Distance</th>
                            <th>Result </th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>nav_per_share</td>
                            <td style="text-align: right;"> 10</td>
                            <td>FAILED </td>
                        </tr>
                    </tbody>
                </table>
                </p>

                <p>The Euclidean distance between the expected and tested dataframes is not 0 for all columns. This
                    means
                    that the expected and tested dataframes have different numeric values in the same column(s).</p>
            </section>

            <section id="Boolean Columns">
                <h2>Boolean Columns</h2>

                <p>The boolean comparison is performed by performing an XNOR operation between the expected and tested
                    dataframes.
                    If the XNOR operation returns True, it means that the expected and tested dataframes have the same
                    boolean values in the same column(s).</p>

                <h5>False</h5>

                <p>
                <table>
                    <thead>
                        <tr>
                            <th>Column Name </th>
                            <th style="text-align: right;"> Total XNOR</th>
                            <th>Result </th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>positive_change</td>
                            <td style="text-align: right;"> 1</td>
                            <td>FAILED </td>
                        </tr>
                    </tbody>
                </table>
                </p>

                <p>
                    The XNOR operation between the expected and tested dataframes is not True for all columns. This
                    means
                    that the expected and tested dataframes have different boolean values for the same column(s).</p>
            </section>
        </section>
    </article>
</div>
<script>
    // Path: compare_datasets/statics/report_template.html
    var svg = '<svg class="toc-marker " width="200 " height="200 " xmlns="http://www.w3.org/1000/svg "><path stroke="#444 " stroke-width="3 " fill="transparent " stroke-dasharray="1, 0, 26, 26" stroke-linecap="round " stroke-linejoin="round " transform="translate(-0.5, -0.5) " d="M 43 16 L 43 42" opacity="1" stroke-dashoffset="1"></path></svg>';
    var toc = document.querySelector('.toc');
    toc.innerHTML = svg;
    console.log(toc)
    var longform = document.querySelector('article');
    headers = document.querySelectorAll('article>section');
    // console.log(headers.length)
    // Create a list for the ToC entries
    tocList = document.createElement("ul");

    // Get the h3 tags - ToC entries



    for (i = 0; i < headers.length; i++) {
        id_name = headers[i].id;

        tocListItem = document.createElement("li");
        tocEntry = document.createElement("a");
        tocEntry.setAttribute("href", "#" + id_name);
        tocEntry.innerText = id_name;
        child = headers[i].getElementsByTagName("section");
        tocListItem.appendChild(tocEntry);
        tocList.appendChild(tocListItem);

        if (child.length != 0) {
            for (j = 0; j < child.length; j++) {
                tocList1 = document.createElement("ul");
                tocListItem1 = document.createElement("li");
                tocEntry1 = document.createElement("a");

                tocEntry1.setAttribute("href", "#" + child[j].id);
                tocEntry1.innerText = child[j].id;
                console.log(tocEntry1);


                tocListItem1.appendChild(tocEntry1);
                tocList1.appendChild(tocListItem1);
                tocListItem.appendChild(tocList1);
                console.log(tocListItem1);
            }
        }



        toc.appendChild(tocList);
    }
    var tocPath = document.querySelector('.toc-marker path');
    var tocItems;

    // Factor of screen size that the element must cross
    // before it's considered visible
    var TOP_MARGIN = 0.1,
        BOTTOM_MARGIN = 0.2;

    var pathLength;

    var lastPathStart,
        lastPathEnd;

    window.addEventListener('resize', drawPath, false);
    window.addEventListener('scroll', sync, false);

    drawPath();

    function drawPath() {

        tocItems = [].slice.call(toc.querySelectorAll('li'));

        // Cache element references and measurements
        tocItems = tocItems.map(function (item) {
            var anchor = item.querySelector('a');
            var target = document.getElementById(anchor.getAttribute('href').slice(1));

            return {
                listItem: item,
                anchor: anchor,
                target: target
            };
        });

        // Remove missing targets
        tocItems = tocItems.filter(function (item) {
            return !!item.target;
        });

        var path = [];
        var pathIndent;

        tocItems.forEach(function (item, i) {

            var x = item.anchor.offsetLeft - 5,
                y = item.anchor.offsetTop,
                height = item.anchor.offsetHeight;

            if (i === 0) {
                path.push('M', x, y, 'L', x, y + height);
                item.pathStart = 0;
            }
            else {
                // Draw an additional line when there's a change in
                // indent levels
                if (pathIndent !== x) path.push('L', pathIndent, y);

                path.push('L', x, y);

                // Set the current path so that we can measure it
                tocPath.setAttribute('d', path.join(' '));
                item.pathStart = tocPath.getTotalLength() || 0;

                path.push('L', x, y + height);
            }

            pathIndent = x;

            tocPath.setAttribute('d', path.join(' '));
            item.pathEnd = tocPath.getTotalLength();

        });

        pathLength = tocPath.getTotalLength();

        sync();

    }

    function sync() {

        var windowHeight = window.innerHeight;

        var pathStart = pathLength,
            pathEnd = 0;

        var visibleItems = 0;

        tocItems.forEach(function (item) {

            var targetBounds = item.target.getBoundingClientRect();

            if (targetBounds.bottom > windowHeight * TOP_MARGIN && targetBounds.top < windowHeight * (1 - BOTTOM_MARGIN)) {
                pathStart = Math.min(item.pathStart, pathStart);
                pathEnd = Math.max(item.pathEnd, pathEnd);

                visibleItems += 1;

                item.listItem.classList.add('visible');
            }
            else {
                item.listItem.classList.remove('visible');
            }

        });

        // Specify the visible path or hide the path altogether
        // if there are no visible items
        if (visibleItems > 0 && pathStart < pathEnd) {
            if (pathStart !== lastPathStart || pathEnd !== lastPathEnd) {
                tocPath.setAttribute('stroke-dashoffset', '1');
                tocPath.setAttribute('stroke-dasharray', '1, ' + pathStart + ', ' + (pathEnd - pathStart) + ', ' + pathLength);
                tocPath.setAttribute('opacity', 1);
            }
        }
        else {
            tocPath.setAttribute('opacity', 0);
        }

        lastPathStart = pathStart;
        lastPathEnd = pathEnd;

    }
</script>

</html>